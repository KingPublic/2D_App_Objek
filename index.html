<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paint 2D - Grafika Komputer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #2c2c2c;
            font-family: Arial, sans-serif;
        }
        main {
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>
<body>
    <main></main>
    <script>
// Aplikasi Paint 2D Interaktif - p5.js
// Fitur lengkap: Drawing, Transform, Selection, Windowing & Clipping
// Dengan Algoritma: Cohen-Sutherland Line Clipping & Sutherland-Hodgman Polygon Clipping

let shapes = [];
let selectedShapes = [];
let history = [];
let historyIndex = -1;

// State
let mode = "select";
let isDrawing = false;
let startPoint = { x: 0, y: 0 };
let currentShape = null;

// Atribut
let currentColor;
let strokeWeightValue = 2;
let fillEnabled = false;

// Clipping Window
let clipWindow = null;
let isSettingWindow = false;
let showClipping = false;

// UI
let showHelp = true;
let palette = [];
let selectedColorIndex = 0;

// Cohen-Sutherland Region Codes
const INSIDE = 0;
const LEFT = 1;
const RIGHT = 2;
const BOTTOM = 4;
const TOP = 8;

function setup() {
  createCanvas(1400, 800);
  
  palette = [
    color(0, 0, 0),
    color(255, 0, 0),
    color(0, 255, 0),
    color(0, 0, 255),
    color(255, 255, 0),
    color(255, 0, 255),
    color(0, 255, 255),
    color(255, 136, 0),
    color(139, 69, 19),
    color(128, 0, 128),
    color(0, 128, 0),
    color(255, 192, 203)
  ];
  
  currentColor = palette[0];
  saveToHistory();
}

function draw() {
  background(255);
  drawGrid();
  
  // Draw shapes with clipping
  if (showClipping && clipWindow !== null) {
    // Draw dimmed shapes
    for (let s of shapes) {
      push();
      tint(255, 100);
      s.display();
      pop();
    }
    
    // Draw clipped shapes
    push();
    drawingContext.save();
    drawingContext.beginPath();
    drawingContext.rect(clipWindow.x, clipWindow.y, clipWindow.w, clipWindow.h);
    drawingContext.clip();
    
    for (let s of shapes) {
      s.displayClipped(clipWindow);
    }
    
    drawingContext.restore();
    pop();
  } else {
    for (let s of shapes) {
      s.display();
    }
  }
  
  // Draw current shape
  if (currentShape !== null) {
    if (showClipping && clipWindow !== null) {
      push();
      drawingContext.save();
      drawingContext.beginPath();
      drawingContext.rect(clipWindow.x, clipWindow.y, clipWindow.w, clipWindow.h);
      drawingContext.clip();
      currentShape.display();
      drawingContext.restore();
      pop();
    } else {
      currentShape.display();
    }
  }
  
  // Draw clipping window
  if (clipWindow !== null && (showClipping || isSettingWindow)) {
    clipWindow.display(isSettingWindow);
  }
  
  // Draw selection
  for (let s of selectedShapes) {
    s.drawSelection();
  }
  
  // Draw UI
  drawToolbar();
  drawInfoBar();
  
  if (showHelp) {
    drawHelpPanel();
  }
}

function drawGrid() {
  stroke(240);
  strokeWeight(1);
  for (let i = 0; i < width; i += 50) {
    line(i, 80, i, height);
  }
  for (let i = 80; i < height; i += 50) {
    line(0, i, width, i);
  }
}

function drawToolbar() {
  fill(50);
  noStroke();
  rect(0, 0, width, 70);
  
  let tools = ["Select", "Point", "Line", "Rect", "Ellipse", "Window"];
  let modeNames = ["select", "point", "line", "rectangle", "ellipse", "window"];
  
  for (let i = 0; i < tools.length; i++) {
    let x = 10 + i * 100;
    drawButton(x, 10, 95, 50, tools[i], mode === modeNames[i]);
  }
  
  textAlign(LEFT, CENTER);
  fill(255);
  textSize(12);
  text("Colors:", 630, 25);
  
  for (let i = 0; i < palette.length; i++) {
    let x = 690 + (i % 6) * 30;
    let y = 10 + floor(i / 6) * 25;
    
    fill(palette[i]);
    stroke(selectedColorIndex === i ? color(100, 200, 255) : color(150));
    strokeWeight(selectedColorIndex === i ? 3 : 1);
    rect(x, y, 25, 20);
  }
  
  fill(255);
  textAlign(LEFT, CENTER);
  text("Stroke: " + nf(strokeWeightValue, 0, 1), 880, 25);
  
  stroke(150);
  strokeWeight(1);
  fill(100);
  rect(950, 15, 100, 20);
  
  fill(100, 200, 255);
  noStroke();
  let sliderX = map(strokeWeightValue, 1, 20, 950, 1050);
  rect(950, 15, sliderX - 950, 20);
  
  drawButton(1070, 10, 80, 50, "Fill: " + (fillEnabled ? "ON" : "OFF"), fillEnabled);
  drawButton(1160, 10, 80, 25, "Clip: " + (showClipping ? "ON" : "OFF"), showClipping);
  drawButton(1160, 35, 80, 25, "Help", showHelp);
  drawButton(1250, 10, 70, 25, "Clear", false);
  drawButton(1250, 35, 70, 25, "Save", false);
  drawButton(1330, 10, 60, 25, "Undo", false);
  drawButton(1330, 35, 60, 25, "Redo", false);
}

function drawButton(x, y, w, h, label, active) {
  if (active) {
    fill(70, 130, 255);
  } else {
    fill(80);
  }
  
  if (mouseX > x && mouseX < x + w && mouseY > y && mouseY < y + h) {
    fill(active ? color(90, 150, 255) : color(100));
  }
  
  noStroke();
  rect(x, y, w, h, 5);
  
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(11);
  text(label, x + w/2, y + h/2);
}

function drawInfoBar() {
  fill(40);
  noStroke();
  rect(0, 70, width, 10);
  
  fill(255);
  textAlign(LEFT, CENTER);
  textSize(10);
  let clipStatus = showClipping && clipWindow ? " | CLIPPING: Cohen-Sutherland" : "";
  text("Objects: " + shapes.length + " | Selected: " + selectedShapes.length + 
       " | Mode: " + mode.toUpperCase() + clipStatus, 10, 75);
}

function drawHelpPanel() {
  fill(0, 0, 0, 230);
  noStroke();
  rect(10, 90, 420, 550, 10);
  
  fill(255, 255, 100);
  textAlign(LEFT, TOP);
  textSize(16);
  text("ðŸ“‹ PANDUAN KONTROL", 20, 100);
  
  fill(200, 50, 50);
  rect(390, 95, 30, 30, 5);
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(20);
  text("Ã—", 405, 110);
  
  fill(255);
  textAlign(LEFT, TOP);
  textSize(11);
  
  let helpText = [
    "",
    "ðŸ–±ï¸ MOUSE:",
    "  â€¢ Klik: Gambar point / Pilih objek",
    "  â€¢ Drag: Gambar shape (garis, persegi, elips)",
    "  â€¢ Shift+Klik: Multi-select objek",
    "",
    "âŒ¨ï¸ KEYBOARD SHORTCUTS:",
    "  ðŸŽ¨ Tools:",
    "    â€¢ V: Select tool",
    "    â€¢ P: Point tool",
    "    â€¢ L: Line tool",
    "    â€¢ B: Box/Rectangle tool",
    "    â€¢ E: Ellipse tool",
    "    â€¢ W: Window/Clipping tool",
    "",
    "  âœï¸ Transform (objek terpilih):",
    "    â€¢ Arrow Keys (â†‘â†“â†â†’): Geser objek",
    "    â€¢ R/r: Rotasi +15Â°/-15Â°",
    "    â€¢ +/-: Scale 110%/90%",
    "    â€¢ Delete/Backspace: Hapus objek",
    "",
    "  ðŸ”§ Other:",
    "    â€¢ C: Toggle clipping ON/OFF",
    "    â€¢ F: Toggle fill ON/OFF",
    "    â€¢ H: Toggle help panel",
    "    â€¢ Ctrl+A: Select all",
    "    â€¢ Ctrl+Z: Undo",
    "    â€¢ Ctrl+Y: Redo",
    "    â€¢ Ctrl+S: Save image",
    "    â€¢ Escape: Clear selection",
    "",
    "ðŸªŸ CLIPPING (Cohen-Sutherland):",
    "  â€¢ Tekan W untuk Window mode",
    "  â€¢ Drag mouse untuk set area",
    "  â€¢ Tekan C untuk aktifkan clipping",
    "  â€¢ Gambar dipotong tepat di boundary",
    "",
    "ðŸ’¡ TIPS:",
    "  â€¢ Klik warna di palette untuk ganti warna",
    "  â€¢ Drag slider untuk ubah ketebalan garis"
  ];
  
  let y = 140;
  for (let line of helpText) {
    text(line, 20, y);
    y += 14;
  }
}

function mousePressed() {
  if (mouseY < 70) {
    handleUIClick();
    return;
  }
  
  if (showHelp && mouseX > 390 && mouseX < 420 && mouseY > 95 && mouseY < 125) {
    showHelp = false;
    return;
  }
  
  isDrawing = true;
  startPoint.x = mouseX;
  startPoint.y = mouseY;
  
  if (mode === "select") {
    handleSelection();
  } else if (mode === "window") {
    isSettingWindow = true;
    clipWindow = new ClipWindow(mouseX, mouseY, 0, 0);
  } else if (mode === "point") {
    let p = new Point(mouseX, mouseY, currentColor, strokeWeightValue, fillEnabled);
    shapes.push(p);
    saveToHistory();
  } else {
    if (mode === "line") {
      currentShape = new Line(mouseX, mouseY, mouseX, mouseY, currentColor, strokeWeightValue, fillEnabled);
    } else if (mode === "rectangle") {
      currentShape = new Rectangle(mouseX, mouseY, 0, 0, currentColor, strokeWeightValue, fillEnabled);
    } else if (mode === "ellipse") {
      currentShape = new Ellipse(mouseX, mouseY, 0, 0, currentColor, strokeWeightValue, fillEnabled);
    }
  }
}

function mouseDragged() {
  if (!isDrawing) return;
  
  if (mode === "window" && isSettingWindow) {
    clipWindow.w = mouseX - clipWindow.x;
    clipWindow.h = mouseY - clipWindow.y;
  } else if (currentShape !== null) {
    if (currentShape instanceof Line) {
      currentShape.x2 = mouseX;
      currentShape.y2 = mouseY;
    } else if (currentShape instanceof Rectangle) {
      currentShape.x = min(startPoint.x, mouseX);
      currentShape.y = min(startPoint.y, mouseY);
      currentShape.w = abs(mouseX - startPoint.x);
      currentShape.h = abs(mouseY - startPoint.y);
    } else if (currentShape instanceof Ellipse) {
      currentShape.x = min(startPoint.x, mouseX);
      currentShape.y = min(startPoint.y, mouseY);
      currentShape.w = abs(mouseX - startPoint.x);
      currentShape.h = abs(mouseY - startPoint.y);
    }
  }
}

function mouseReleased() {
  if (currentShape !== null && mode !== "point") {
    shapes.push(currentShape);
    saveToHistory();
    currentShape = null;
  }
  
  if (isSettingWindow && clipWindow !== null) {
    if (clipWindow.w < 0) {
      clipWindow.x += clipWindow.w;
      clipWindow.w = abs(clipWindow.w);
    }
    if (clipWindow.h < 0) {
      clipWindow.y += clipWindow.h;
      clipWindow.h = abs(clipWindow.h);
    }
    isSettingWindow = false;
  }
  
  isDrawing = false;
}

function handleUIClick() {
  let modeNames = ["select", "point", "line", "rectangle", "ellipse", "window"];
  for (let i = 0; i < 6; i++) {
    let x = 10 + i * 100;
    if (mouseX > x && mouseX < x + 95 && mouseY > 10 && mouseY < 60) {
      mode = modeNames[i];
      if (mode !== "select") {
        selectedShapes = [];
      }
      return;
    }
  }
  
  for (let i = 0; i < palette.length; i++) {
    let x = 690 + (i % 6) * 30;
    let y = 10 + floor(i / 6) * 25;
    if (mouseX > x && mouseX < x + 25 && mouseY > y && mouseY < y + 20) {
      currentColor = palette[i];
      selectedColorIndex = i;
      for (let s of selectedShapes) {
        s.col = currentColor;
      }
      return;
    }
  }
  
  if (mouseX > 950 && mouseX < 1050 && mouseY > 15 && mouseY < 35) {
    strokeWeightValue = map(mouseX, 950, 1050, 1, 20);
    for (let s of selectedShapes) {
      s.strokeW = strokeWeightValue;
    }
    return;
  }
  
  if (mouseX > 1070 && mouseX < 1150 && mouseY > 10 && mouseY < 60) {
    fillEnabled = !fillEnabled;
    return;
  }
  
  if (mouseX > 1160 && mouseX < 1240 && mouseY > 10 && mouseY < 35) {
    showClipping = !showClipping;
    return;
  }
  
  if (mouseX > 1160 && mouseX < 1240 && mouseY > 35 && mouseY < 60) {
    showHelp = !showHelp;
    return;
  }
  
  if (mouseX > 1250 && mouseX < 1320 && mouseY > 10 && mouseY < 35) {
    if (shapes.length > 0) {
      shapes = [];
      selectedShapes = [];
      clipWindow = null;
      saveToHistory();
    }
    return;
  }
  
  if (mouseX > 1250 && mouseX < 1320 && mouseY > 35 && mouseY < 60) {
    saveImage();
    return;
  }
  
  if (mouseX > 1330 && mouseX < 1390 && mouseY > 10 && mouseY < 35) {
    undo();
    return;
  }
  
  if (mouseX > 1330 && mouseX < 1390 && mouseY > 35 && mouseY < 60) {
    redo();
    return;
  }
}

function handleSelection() {
  let found = false;
  let shiftPressed = keyIsDown(SHIFT);
  
  if (!shiftPressed) {
    selectedShapes = [];
  }
  
  for (let i = shapes.length - 1; i >= 0; i--) {
    let s = shapes[i];
    if (s.contains(mouseX, mouseY)) {
      let index = selectedShapes.indexOf(s);
      if (index > -1) {
        selectedShapes.splice(index, 1);
      } else {
        selectedShapes.push(s);
      }
      found = true;
      break;
    }
  }
  
  if (!found && !shiftPressed) {
    selectedShapes = [];
  }
}

function keyPressed() {
  // Tool shortcuts (without Ctrl)
  if (!keyIsDown(CONTROL) && !keyIsDown(91)) {
    if (key === 'v' || key === 'V') {
      mode = "select";
      selectedShapes = [];
      return;
    }
    
    if (key === 'p' || key === 'P') {
      mode = "point";
      selectedShapes = [];
      return;
    }
    
    if (key === 'l' || key === 'L') {
      mode = "line";
      selectedShapes = [];
      return;
    }
    
    if (key === 'b' || key === 'B') {
      mode = "rectangle";
      selectedShapes = [];
      return;
    }
    
    if (key === 'e' || key === 'E') {
      mode = "ellipse";
      selectedShapes = [];
      return;
    }
    
    if (key === 'w' || key === 'W') {
      mode = "window";
      selectedShapes = [];
      return;
    }
    
    if (key === 'c' || key === 'C') {
      showClipping = !showClipping;
      return;
    }
    
    if (key === 'h' || key === 'H') {
      showHelp = !showHelp;
      return;
    }
    
    if (key === 'f' || key === 'F') {
      fillEnabled = !fillEnabled;
      return;
    }
  }
  
  // Ctrl shortcuts
  if ((keyIsDown(CONTROL) || keyIsDown(91)) && (key === 'a' || key === 'A')) {
    selectedShapes = [];
    for (let s of shapes) {
      selectedShapes.push(s);
    }
    mode = "select";
    return false;
  }
  
  if ((keyIsDown(CONTROL) || keyIsDown(91)) && (key === 'z' || key === 'Z')) {
    undo();
    return false;
  }
  
  if ((keyIsDown(CONTROL) || keyIsDown(91)) && (key === 'y' || key === 'Y')) {
    redo();
    return false;
  }
  
  if ((keyIsDown(CONTROL) || keyIsDown(91)) && (key === 's' || key === 'S')) {
    saveImage();
    return false;
  }
  
  // Transform selected shapes
  if (selectedShapes.length === 0) return;
  
  let needsSave = true;
  
  for (let s of selectedShapes) {
    if (keyCode === UP_ARROW) {
      s.translate(0, -10);
    } else if (keyCode === DOWN_ARROW) {
      s.translate(0, 10);
    } else if (keyCode === LEFT_ARROW) {
      s.translate(-10, 0);
    } else if (keyCode === RIGHT_ARROW) {
      s.translate(10, 0);
    } else if (key === 'r') {
      s.rotate(-radians(15));
    } else if (key === 'R') {
      s.rotate(radians(15));
    } else if (key === '+' || key === '=') {
      s.scale(1.1);
    } else if (key === '-' || key === '_') {
      s.scale(0.9);
    } else if (keyCode === DELETE || keyCode === BACKSPACE) {
      // Will handle after loop
    } else if (keyCode === ESCAPE) {
      selectedShapes = [];
      needsSave = false;
    } else {
      needsSave = false;
    }
  }
  
  if (keyCode === DELETE || keyCode === BACKSPACE) {
    shapes = shapes.filter(s => !selectedShapes.includes(s));
    selectedShapes = [];
    saveToHistory();
  } else if (needsSave) {
    saveToHistory();
  }
  
  if (keyCode === UP_ARROW || keyCode === DOWN_ARROW || 
      keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW) {
    return false;
  }
}

function saveToHistory() {
  while (history.length > historyIndex + 1) {
    history.pop();
  }
  
  let snapshot = [];
  for (let s of shapes) {
    snapshot.push(s.clone());
  }
  
  history.push(snapshot);
  historyIndex++;
  
  if (history.length > 50) {
    history.shift();
    historyIndex--;
  }
}

function undo() {
  if (historyIndex > 0) {
    historyIndex--;
    shapes = [];
    for (let s of history[historyIndex]) {
      shapes.push(s.clone());
    }
    selectedShapes = [];
  }
}

function redo() {
  if (historyIndex < history.length - 1) {
    historyIndex++;
    shapes = [];
    for (let s of history[historyIndex]) {
      shapes.push(s.clone());
    }
    selectedShapes = [];
  }
}

function saveImage() {
  let filename = "paint_" + year() + nf(month(), 2) + nf(day(), 2) + "_" + 
                 nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2) + ".png";
  save(filename);
  console.log("Image saved as: " + filename);
}

// ==================== CLIPPING ALGORITHMS ====================

function computeRegionCode(x, y, clip) {
  let code = INSIDE;
  
  if (x < clip.x) code |= LEFT;
  else if (x > clip.x + clip.w) code |= RIGHT;
  
  if (y < clip.y) code |= TOP;
  else if (y > clip.y + clip.h) code |= BOTTOM;
  
  return code;
}

function cohenSutherlandClip(x1, y1, x2, y2, clip) {
  let code1 = computeRegionCode(x1, y1, clip);
  let code2 = computeRegionCode(x2, y2, clip);
  let accept = false;
  
  while (true) {
    if ((code1 | code2) === 0) {
      accept = true;
      break;
    } else if (code1 & code2) {
      break;
    } else {
      let x, y;
      let codeOut = code1 ? code1 : code2;
      
      if (codeOut & TOP) {
        x = x1 + (x2 - x1) * (clip.y - y1) / (y2 - y1);
        y = clip.y;
      } else if (codeOut & BOTTOM) {
        x = x1 + (x2 - x1) * (clip.y + clip.h - y1) / (y2 - y1);
        y = clip.y + clip.h;
      } else if (codeOut & RIGHT) {
        y = y1 + (y2 - y1) * (clip.x + clip.w - x1) / (x2 - x1);
        x = clip.x + clip.w;
      } else if (codeOut & LEFT) {
        y = y1 + (y2 - y1) * (clip.x - x1) / (x2 - x1);
        x = clip.x;
      }
      
      if (codeOut === code1) {
        x1 = x;
        y1 = y;
        code1 = computeRegionCode(x1, y1, clip);
      } else {
        x2 = x;
        y2 = y;
        code2 = computeRegionCode(x2, y2, clip);
      }
    }
  }
  
  if (accept) {
    return { x1, y1, x2, y2, visible: true };
  }
  return { visible: false };
}

function clipPolygonEdge(vertices, edgeX1, edgeY1, edgeX2, edgeY2) {
  let output = [];
  
  for (let i = 0; i < vertices.length; i++) {
    let curr = vertices[i];
    let next = vertices[(i + 1) % vertices.length];
    
    let currInside = isLeftOfEdge(curr.x, curr.y, edgeX1, edgeY1, edgeX2, edgeY2);
    let nextInside = isLeftOfEdge(next.x, next.y, edgeX1, edgeY1, edgeX2, edgeY2);
    
    if (currInside && nextInside) {
      output.push({ x: next.x, y: next.y });
    } else if (currInside && !nextInside) {
      let intersection = lineIntersection(curr.x, curr.y, next.x, next.y, edgeX1, edgeY1, edgeX2, edgeY2);
      if (intersection) output.push(intersection);
    } else if (!currInside && nextInside) {
      let intersection = lineIntersection(curr.x, curr.y, next.x, next.y, edgeX1, edgeY1, edgeX2, edgeY2);
      if (intersection) output.push(intersection);
      output.push({ x: next.x, y: next.y });
    }
  }
  
  return output;
}

function isLeftOfEdge(px, py, x1, y1, x2, y2) {
  return ((x2 - x1) * (py - y1) - (y2 - y1) * (px - x1)) >= 0;
}

function lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
  let denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  if (abs(denom) < 0.001) return null;
  
  let t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
  
  return {
    x: x1 + t * (x2 - x1),
    y: y1 + t * (y2 - y1)
  };
}

// ==================== CLASSES ====================

class Shape {
  constructor(c, sw, f) {
    this.col = c;
    this.strokeW = sw;
    this.fill = f;
  }
  
  display() {}
  displayClipped(clip) { this.display(); }
  contains(x, y) { return false; }
  translate(dx, dy) {}
  rotate(angle) {}
  scale(factor) {}
  drawSelection() {}
  clone() { return null; }
}

class Point extends Shape {
  constructor(px, py, c, sw, f) {
    super(c, sw, f);
    this.x = px;
    this.y = py;
  }
  
  display() {
    fill(this.col);
    noStroke();
    circle(this.x, this.y, this.strokeW * 4);
  }
  
  displayClipped(clip) {
    if (this.x >= clip.x && this.x <= clip.x + clip.w &&
        this.y >= clip.y && this.y <= clip.y + clip.h) {
      this.display();
    }
  }
  
  contains(px, py) {
    return dist(px, py, this.x, this.y) < 15;
  }
  
  translate(dx, dy) {
    this.x += dx;
    this.y += dy;
  }
  
  rotate(angle) {}
  
  scale(factor) {
    this.strokeW *= factor;
  }
  
  drawSelection() {
    noFill();
    stroke(255, 100, 100);
    strokeWeight(2);
    circle(this.x, this.y, 30);
  }
  
  clone() {
    return new Point(this.x, this.y, this.col, this.strokeW, this.fill);
  }
}

class Line extends Shape {
  constructor(px1, py1, px2, py2, c, sw, f) {
    super(c, sw, f);
    this.x1 = px1;
    this.y1 = py1;
    this.x2 = px2;
    this.y2 = py2;
  }
  
  display() {
    stroke(this.col);
    strokeWeight(this.strokeW);
    line(this.x1, this.y1, this.x2, this.y2);
  }
  
  displayClipped(clip) {
    let clipped = cohenSutherlandClip(this.x1, this.y1, this.x2, this.y2, clip);
    
    if (clipped.visible) {
      stroke(this.col);
      strokeWeight(this.strokeW);
      line(clipped.x1, clipped.y1, clipped.x2, clipped.y2);
    }
  }
  
  contains(px, py) {
    let d = this.distToSegment(px, py, this.x1, this.y1, this.x2, this.y2);
    return d < 10;
  }
  
  distToSegment(px, py, lx1, ly1, lx2, ly2) {
    let dx = lx2 - lx1;
    let dy = ly2 - ly1;
    let t = ((px - lx1) * dx + (py - ly1) * dy) / (dx * dx + dy * dy);
    t = constrain(t, 0, 1);
    let closestX = lx1 + t * dx;
    let closestY = ly1 + t * dy;
    return dist(px, py, closestX, closestY);
  }
  
  translate(dx, dy) {
    this.x1 += dx;
    this.y1 += dy;
    this.x2 += dx;
    this.y2 += dy;
  }
  
  rotate(angle) {
    let cx = (this.x1 + this.x2) / 2;
    let cy = (this.y1 + this.y2) / 2;
    
    let dx1 = this.x1 - cx;
    let dy1 = this.y1 - cy;
    let dx2 = this.x2 - cx;
    let dy2 = this.y2 - cy;
    
    this.x1 = cx + dx1 * cos(angle) - dy1 * sin(angle);
    this.y1 = cy + dx1 * sin(angle) + dy1 * cos(angle);
    this.x2 = cx + dx2 * cos(angle) - dy2 * sin(angle);
    this.y2 = cy + dx2 * sin(angle) + dy2 * cos(angle);
  }
  
  scale(factor) {
    let cx = (this.x1 + this.x2) / 2;
    let cy = (this.y1 + this.y2) / 2;
    
    this.x1 = cx + (this.x1 - cx) * factor;
    this.y1 = cy + (this.y1 - cy) * factor;
    this.x2 = cx + (this.x2 - cx) * factor;
    this.y2 = cy + (this.y2 - cy) * factor;
  }
  
  drawSelection() {
    let minX = min(this.x1, this.x2) - 5;
    let minY = min(this.y1, this.y2) - 5;
    let maxX = max(this.x1, this.x2) + 5;
    let maxY = max(this.y1, this.y2) + 5;
    
    noFill();
    stroke(255, 100, 100);
    strokeWeight(2);
    rect(minX, minY, maxX - minX, maxY - minY);
  }
  
  clone() {
    return new Line(this.x1, this.y1, this.x2, this.y2, this.col, this.strokeW, this.fill);
  }
}

class Rectangle extends Shape {
  constructor(px, py, pw, ph, c, sw, f) {
    super(c, sw, f);
    this.x = px;
    this.y = py;
    this.w = pw;
    this.h = ph;
  }
  
  display() {
    if (this.fill) {
      fill(this.col);
    } else {
      noFill();
    }
    stroke(this.col);
    strokeWeight(this.strokeW);
    rect(this.x, this.y, this.w, this.h);
  }
  
  displayClipped(clip) {
    let vertices = [
      { x: this.x, y: this.y },
      { x: this.x + this.w, y: this.y },
      { x: this.x + this.w, y: this.y + this.h },
      { x: this.x, y: this.y + this.h }
    ];
    
    vertices = clipPolygonEdge(vertices, clip.x, clip.y, clip.x + clip.w, clip.y);
    if (vertices.length === 0) return;
    vertices = clipPolygonEdge(vertices, clip.x + clip.w, clip.y, clip.x + clip.w, clip.y + clip.h);
    if (vertices.length === 0) return;
    vertices = clipPolygonEdge(vertices, clip.x + clip.w, clip.y + clip.h, clip.x, clip.y + clip.h);
    if (vertices.length === 0) return;
    vertices = clipPolygonEdge(vertices, clip.x, clip.y + clip.h, clip.x, clip.y);
    
    if (vertices.length > 0) {
      if (this.fill) {
        fill(this.col);
      } else {
        noFill();
      }
      stroke(this.col);
      strokeWeight(this.strokeW);
      
      beginShape();
      for (let v of vertices) {
        vertex(v.x, v.y);
      }
      endShape(CLOSE);
    }
  }
  
  contains(px, py) {
    return px >= this.x && px <= this.x + this.w && 
           py >= this.y && py <= this.y + this.h;
  }
  
  translate(dx, dy) {
    this.x += dx;
    this.y += dy;
  }
  
  rotate(angle) {}
  
  scale(factor) {
    let cx = this.x + this.w / 2;
    let cy = this.y + this.h / 2;
    this.w *= factor;
    this.h *= factor;
    this.x = cx - this.w / 2;
    this.y = cy - this.h / 2;
  }
  
  drawSelection() {
    noFill();
    stroke(255, 100, 100);
    strokeWeight(2);
    rect(this.x - 5, this.y - 5, this.w + 10, this.h + 10);
  }
  
  clone() {
    return new Rectangle(this.x, this.y, this.w, this.h, this.col, this.strokeW, this.fill);
  }
}

class Ellipse extends Shape {
  constructor(px, py, pw, ph, c, sw, f) {
    super(c, sw, f);
    this.x = px;
    this.y = py;
    this.w = pw;
    this.h = ph;
  }
  
  display() {
    if (this.fill) {
      fill(this.col);
    } else {
      noFill();
    }
    stroke(this.col);
    strokeWeight(this.strokeW);
    ellipse(this.x + this.w/2, this.y + this.h/2, this.w, this.h);
  }
  
  displayClipped(clip) {
    let cx = this.x + this.w / 2;
    let cy = this.y + this.h / 2;
    let vertices = [];
    let segments = 32;
    
    for (let i = 0; i < segments; i++) {
      let angle = (i / segments) * TWO_PI;
      vertices.push({
        x: cx + cos(angle) * this.w / 2,
        y: cy + sin(angle) * this.h / 2
      });
    }
    
    vertices = clipPolygonEdge(vertices, clip.x, clip.y, clip.x + clip.w, clip.y);
    if (vertices.length === 0) return;
    vertices = clipPolygonEdge(vertices, clip.x + clip.w, clip.y, clip.x + clip.w, clip.y + clip.h);
    if (vertices.length === 0) return;
    vertices = clipPolygonEdge(vertices, clip.x + clip.w, clip.y + clip.h, clip.x, clip.y + clip.h);
    if (vertices.length === 0) return;
    vertices = clipPolygonEdge(vertices, clip.x, clip.y + clip.h, clip.x, clip.y);
    
    if (vertices.length > 0) {
      if (this.fill) {
        fill(this.col);
      } else {
        noFill();
      }
      stroke(this.col);
      strokeWeight(this.strokeW);
      
      beginShape();
      for (let v of vertices) {
        vertex(v.x, v.y);
      }
      endShape(CLOSE);
    }
  }
  
  contains(px, py) {
    let cx = this.x + this.w / 2;
    let cy = this.y + this.h / 2;
    let dx = (px - cx) / (this.w / 2);
    let dy = (py - cy) / (this.h / 2);
    return (dx * dx + dy * dy) <= 1;
  }
  
  translate(dx, dy) {
    this.x += dx;
    this.y += dy;
  }
  
  rotate(angle) {}
  
  scale(factor) {
    let cx = this.x + this.w / 2;
    let cy = this.y + this.h / 2;
    this.w *= factor;
    this.h *= factor;
    this.x = cx - this.w / 2;
    this.y = cy - this.h / 2;
  }
  
  drawSelection() {
    noFill();
    stroke(255, 100, 100);
    strokeWeight(2);
    rect(this.x - 5, this.y - 5, this.w + 10, this.h + 10);
  }
  
  clone() {
    return new Ellipse(this.x, this.y, this.w, this.h, this.col, this.strokeW, this.fill);
  }
}

class ClipWindow {
  constructor(px, py, pw, ph) {
    this.x = px;
    this.y = py;
    this.w = pw;
    this.h = ph;
  }
  
  display(isSetting) {
    if (isSetting) {
      stroke(255, 0, 0);
    } else {
      stroke(0, 0, 255);
    }
    
    strokeWeight(3);
    noFill();
    rect(this.x, this.y, this.w, this.h);
    
    fill(0, 0, 255, 30);
    noStroke();
    rect(this.x, this.y, this.w, this.h);
    
    fill(0, 0, 255);
    textAlign(CENTER, BOTTOM);
    textSize(12);
    text("CLIP WINDOW", this.x + this.w/2, this.y - 5);
  }
}
    </script>
</body>
</html>